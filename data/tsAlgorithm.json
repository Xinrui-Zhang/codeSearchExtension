{"index":{"_index":"codesearch"}}
{"name": "queue","description": "先进先出队列的链表实现","link":"https://github.com/originalix/algorithm/","code": "import { IQueue } from '@/types'<br />import { NodeItem } from '@/algs4/1-3/node-item'<br /><br />/**<br /> * 先进先出队列（链表实现）<br /> */<br />export default class Queue<T> implements IQueue<T> {<br />  public first: NodeItem<T><br />  public last: NodeItem<T><br />  private N: number<br /><br />  constructor() {<br />    this.N = 0<br />    this.first = null<br />    this.last = null<br />  }<br /><br />  isEmpty(): boolean {<br />    return this.N === 0<br />  }<br />  size(): number {<br />    return this.N<br />  }<br /><br />  enqueue(item: T) {<br />    const oldLast = this.last<br />    this.last = new NodeItem<T>()<br />    this.last.item = item<br />    this.last.next = null<br />    if (this.isEmpty()) {<br />      this.first = this.last<br />    } else {<br />      oldLast.next = this.last<br />    }<br />    this.N++<br />  }<br /><br />  dequeue(): T {<br />    const item = this.first.item<br />    this.first = this.first.next<br />    if (this.isEmpty()) {<br />      this.last = null<br />    }<br />    this.N--<br />    return item<br />  }<br />}<br /><br />import { INodeItem, INodeIterator } from '@/types'<br /><br />/**<br /> * 链表节点<br /> */<br />export class NodeItem<T> implements INodeItem<T> {<br />  item: T<br />  next: NodeItem<T><br />}<br /><br />/**<br /> * 链表 迭代<br /> */<br />export class NodeIterator<T> implements INodeIterator<T> {<br />  private current: NodeItem<T><br /><br />  protected setCurrent(first: NodeItem<T>) {<br />    this.current = first<br />  }<br /><br />  hasNext(): boolean {<br />    return this.current && this.current !== null<br />  }<br /><br />  // eslint-disable-next-line @typescript-eslint/no-empty-function<br />  remove() {}<br /><br />  next(): T {<br />    const item = this.current.item<br />    this.current = this.current.next<br />    return item<br />  }<br />}<br />"}
{"index":{"_index":"codesearch"}}
{"name": "stack","description": "下压栈的链表实现","link":"https://github.com/originalix/algorithm/","code": "import { IStack } from '@/types'<br />import { NodeItem } from '@/algs4/1-3/node-item'<br /><br />/**<br /> * 下压栈(链表实现)<br /> */<br />export default class Stack<T> implements IStack<T> {<br />  private first: NodeItem<T><br />  private N: number<br /><br />  constructor() {<br />    this.N = 0<br />  }<br /><br />  isEmpty(): boolean {<br />    return this.N === 0<br />  }<br /><br />  size(): number {<br />    return this.N<br />  }<br /><br />  push(item: T) {<br />    const oldFirst = this.first<br />    this.first = new NodeItem<T>()<br />    this.first.item = item<br />    this.first.next = oldFirst<br />    this.N++<br />  }<br /><br />  pop(): T {<br />    const item = this.first.item<br />    this.first = this.first.next<br />    this.N--<br />    return item<br />  }<br />}<br /><br /><br />import { INodeItem, INodeIterator } from '@/types'<br /><br />/**<br /> * 链表节点<br /> */<br />export class NodeItem<T> implements INodeItem<T> {<br />  item: T<br />  next: NodeItem<T><br />}<br /><br />/**<br /> * 链表 迭代<br /> */<br />export class NodeIterator<T> implements INodeIterator<T> {<br />  private current: NodeItem<T><br /><br />  protected setCurrent(first: NodeItem<T>) {<br />    this.current = first<br />  }<br /><br />  hasNext(): boolean {<br />    return this.current && this.current !== null<br />  }<br /><br />  // eslint-disable-next-line @typescript-eslint/no-empty-function<br />  remove() {}<br /><br />  next(): T {<br />    const item = this.current.item<br />    this.current = this.current.next<br />    return item<br />  }<br />}<br />"}
{"index":{"_index":"codesearch"}}
{"name": "resizing-stack","description": "能够动态调整大小的下压栈","link":"https://github.com/originalix/algorithm/","code": "import { IStack } from '@/types'<br />/**<br /> * 下压栈 (能够动态调整数组大小的实现)<br /> */<br />class ResizingArrayStack<T> implements IStack<T> {<br />  private a: T[]<br />  private N: number<br />  constructor() {<br />    this.a = new Array(1)<br />    this.N = 0<br />  }<br /><br />  isEmpty(): boolean {<br />    return this.N === 0<br />  }<br />  size(): number {<br />    return this.N<br />  }<br />  private resize(max: number) {<br />    const temp: T[] = new Array(max)<br />    for (let i = 0; i < this.N; i++) {<br />      temp[i] = this.a[i]<br />    }<br />    this.a = temp<br />  }<br /><br />  push(item: T) {<br />    if (this.N === this.a.length) this.resize(2 * this.a.length)<br />    this.a[this.N++] = item<br />  }<br /><br />  pop(): T {<br />    const item = this.a[--this.N]<br />    this.a[this.N] = null<br />    if (this.N > 0 && this.N === this.a.length / 4) {<br />      this.resize(this.a.length / 2)<br />    }<br />    return item<br />  }<br />}<br /><br />const stack = new ResizingArrayStack<number>()<br />console.log(`stack should empty: ${stack.isEmpty()}`)<br />for (let i = 0; i < 10; i++) {<br />  stack.push(i)<br />}<br />console.log(`now stack size is ${stack.size()}`)<br />while (!stack.isEmpty()) {<br />  const current = stack.pop()<br />  console.log(`current item is: ${current}`)<br />}<br />console.log(`stack should empty again: ${stack.isEmpty()}`)<br />"}
{"index":{"_index":"codesearch"}}
{"name": "simple-calculate","description": "Dijkstra双栈进行算术表达式的求值计算","link":"https://github.com/originalix/algorithm/","code": "export default class Evaluate {<br />  static main(args: string) {<br />    const ops: string[] = []<br />    const vals: number[] = []<br /><br />    for (let i = 0; i < args.length; i++) {<br />      const char = args.charAt(i)<br />      if (char.match(/\\s/)) continue<br />      if (char === '(') continue<br />      if (['+', '-', '*', '/'].includes(char)) {<br />        ops.push(char)<br />      } else if (char === ')') {<br />        const op = ops.pop()<br />        let v = vals.pop()<br />        if (op === '+') v = vals.pop() + v<br />        if (op === '-') v = vals.pop() - v<br />        if (op === '*') v = vals.pop() * v<br />        if (op === '/') v = vals.pop() / v<br />        vals.push(v)<br />      } else {<br />        vals.push(parseFloat(char))<br />      }<br />    }<br /><br />    return vals.pop()<br />  }<br />}<br />"}
{"index":{"_index":"codesearch"}}
{"name": "binary-search tree", "description": "二叉查找树","link":"https://github.com/originalix/algorithm/", "code": "interface IBst<K, V> extends ICommonFn {<br />  get: (key: K) => V | null<br />  put: (key: K, val: V) => void<br />  rank: (key: K) => number<br />  min: () => K<br />  max: () => K<br />  floor: (key: K) => K<br />  select: (key: number) => K<br />  deleteMin: () => void<br />  delete: (key: K) => void<br />  keys: (lo: K, hi: K) => K[]<br />}<br /><br />export class Node<K, V> {<br />  public key: K<br />  public val: V<br />  public left: Node<K, V> // 指向树的链接<br />  public right: Node<K, V><br />  public N: number // 以该节点为根的子树中的结点总数<br />  constructor(key: K, val: V, N: number) {<br />    this.key = key<br />    this.val = val<br />    this.N = N<br />    this.left = null<br />    this.right = null<br />  }<br />}<br /><br />/**<br /> * 二叉查找树<br /> */<br />export default class BST<K, V> implements IBst<K, V> {<br />  private root: Node<K, V> // 二叉查找树根节点<br />  constructor() {<br />    this.root = null<br />  }<br /><br />  size(): number {<br />    return this._size(this.root)<br />  }<br /><br />  private _size(x: Node<K, V>): number {<br />    if (x === null) return 0<br />    else return x.N<br />  }<br /><br />  isEmpty() {<br />    return this.size() === 0<br />  }<br /><br />  get(key: K) {<br />    return this._get(this.root, key)<br />  }<br /><br />  // 在以 x 为根节点的子树中查找并返回 key 对应的值<br />  private _get(x: Node<K, V>, key: K): V | null {<br />    // 如果找不到则返回 null<br />    if (x === null) return null<br />    if (key < x.key) {<br />      return this._get(x.left, key)<br />    } else if (key > x.key) {<br />      return this._get(x.right, key)<br />    } else {<br />      return x.val<br />    }<br />  }<br /><br />  // 查找 key， 找到则更新它的值，否则为它创建一个新的节点<br />  put(key: K, val: V) {<br />    this.root = this._put(this.root, key, val)<br />  }<br /><br />  // 如果 key 存在于以 x 为根节点的子树中则更新它的值<br />  // 否则将以 key 和 val 为键值对的新节点插入到该子树中<br />  private _put(x: Node<K, V>, key: K, val: V): Node<K, V> {<br />    if (x === null) return new Node(key, val, 1)<br />    if (key < x.key) {<br />      x.left = this._put(x.left, key, val)<br />    } else if (key > x.key) {<br />      x.right = this._put(x.right, key, val)<br />    } else {<br />      x.val = val<br />    }<br />    x.N = this._size(x.left) + this._size(x.right) + 1<br /><br />    return x<br />  }<br /><br />  // 查找最小键<br />  min(): K {<br />    return this._min(this.root)?.key<br />  }<br /><br />  private _min(x: Node<K, V>): Node<K, V> {<br />    if (x.left === null) return x<br />    return this._min(x.left)<br />  }<br /><br />  max(): K {<br />    return this._max(this.root)?.key<br />  }<br /><br />  private _max(x: Node<K, V>): Node<K, V> {<br />    if (x.right === null) return x<br />    return this._max(x.right)<br />  }<br /><br />  // 向上取整<br />  floor(key: K) {<br />    const x = this._floor(this.root, key)<br />    if (x === null) return null<br />    return x.key<br />  }<br /><br />  private _floor(x: Node<K, V>, key: K): Node<K, V> {<br />    if (x === null) return null<br />    if (key === x.key) return x<br />    if (key < x.key) return this._floor(x.left, key)<br />    const t = this._floor(x.right, key)<br />    return t !== null ? t : x<br />  }<br /><br />  //  选择操作<br />  select(k: number) {<br />    return this._select(this.root, k)?.key<br />  }<br /><br />  // 返回排名为 k 的节点<br />  private _select(x: Node<K, V>, k: number): Node<K, V> {<br />    if (x === null) return null<br />    const t = this._size(x.left)<br />    if (t > k) return this._select(x.left, k)<br />    else if (t < k) return this._select(x.right, k - t - 1)<br />    else return x<br />  }<br /><br />  // 排名<br />  rank(key: K): number {<br />    return this._rank(key, this.root)<br />  }<br /><br />  // 返回以 x 为根节点的子树中小于 x.key 的数量<br />  private _rank(key: K, x: Node<K, V>): number {<br />    if (x === null) return 0<br />    if (key < x.key) {<br />      return this._rank(key, x.left)<br />    } else if (key > x.key) {<br />      return 1 + this._size(x.left) + this._rank(key, x.right)<br />    } else {<br />      return this._size(x.left)<br />    }<br />  }<br /><br />  // 删除最小键<br />  deleteMin() {<br />    this.root = this._deleteMin(this.root)<br />  }<br /><br />  private _deleteMin(x: Node<K, V>): Node<K, V> {<br />    if (x.left === null) return x.right<br />    x.left = this._deleteMin(x.left)<br />    x.N = this._size(x.left) + this._size(x.right) + 1<br />    return x<br />  }<br /><br />  // 删除操作<br />  delete(key: K) {<br />    this.root = this._delete(this.root, key)<br />  }<br /><br />  /**<br />   * 删除算法步骤<br />   * 1、将指向即将被删除的节点的链接保存为 t<br />   * 2、将 x 指向它的后继节点 min(t.right)<br />   * 3、将 x 的右链接(原本指向一颗所有节点都大于x.key的二叉查找树)指向 deleteMin(t.right)，也就是在删除后所有结点仍然都大于 x.key 的子二叉查找树<br />   * 4、将 x 的左连接(本为空)设为t.left(其下所有的键都小于被删除的结点和它的后继结点)<br />   */<br />  private _delete(x: Node<K, V>, key: K): Node<K, V> {<br />    if (x === null) return null<br />    if (key < x.key) {<br />      x.left = this._delete(x.left, key)<br />    } else if (key > x.key) {<br />      x.right = this._delete(x.right, key)<br />    } else {<br />      if (x.right === null) return x.left<br />      if (x.left === null) return x.right<br />      const t = x<br />      x = this._min(t.right)<br />      x.right = this._deleteMin(t.right)<br />      x.left = t.left<br />    }<br />    x.N = this._size(x.left) + this._size(x.right) + 1<br />    return x<br />  }<br /><br />  // 范围查找<br />  keys(lo: K, hi: K) {<br />    const queue: K[] = []<br />    this._keys(this.root, queue, lo, hi)<br />    return queue<br />  }<br /><br />  // 中序遍历<br />  private _keys(x: Node<K, V>, queue: K[], lo: K, hi: K) {<br />    if (x === null) return<br />    if (lo < x.key) this._keys(x.left, queue, lo, hi)<br />    if (lo <= x.key && hi >= x.key) queue.push(x.key)<br />    if (hi > x.key) this._keys(x.right, queue, lo, hi)<br />  }<br />}<br />"}
{"index":{"_index":"codesearch"}}
{"name": "binary-search(array)", "description": "二分查找的有序数组实现","link":"https://github.com/originalix/algorithm/", "code": "interface IBst<K, V> extends ICommonFn {<br />  get: (key: K) => V | null<br />  put: (key: K, val: V) => void<br />  rank: (key: K) => number<br />  min: () => K<br />  max: () => K<br />  floor: (key: K) => K<br />  select: (key: number) => K<br />  deleteMin: () => void<br />  delete: (key: K) => void<br />  keys: (lo: K, hi: K) => K[]<br />}<br /><br />export default class BinarySearchST<Key, Value> implements ISearch<Key, Value> {<br />  private keys: Key[]<br />  private vals: Value[]<br />  private N: number<br /><br />  constructor() {<br />    this.keys = []<br />    this.vals = []<br />    this.N = 0<br />  }<br /><br />  size(): number {<br />    return this.N<br />  }<br /><br />  isEmpty(): boolean {<br />    return this.N === 0<br />  }<br /><br />  contains(key: Key) {<br />    return this.get(key) != null<br />  }<br /><br />  getKeys() {<br />    return this.keys<br />  }<br /><br />  get(key: Key): Value | null {<br />    if (this.isEmpty()) return null<br />    const i = this.rank(key, 0, this.N - 1)<br />    if (i < this.N && this.keys[i] === key) {<br />      return this.vals[i]<br />    } else {<br />      return null<br />    }<br />  }<br /><br />  // 查找键，找到则更新值，否则创建新的元素:w<br />  put(key: Key, val: Value) {<br />    const i = this.rank(key, 0, this.N - 1)<br />    if (i < this.N && this.keys[i] === key) {<br />      this.vals[i] = val<br />      return<br />    }<br />    for (let j = this.N; j > i; j--) {<br />      this.keys[j] = this.keys[j - 1]<br />      this.vals[j] = this.vals[j - 1]<br />    }<br />    this.keys[i] = key<br />    this.vals[i] = val<br />    this.N++<br />  }<br /><br />  rank(key: Key, lo: number, hi: number): number {<br />    if (hi < lo) return lo<br />    const mid = Math.floor(lo + (hi - lo) / 2)<br />    if (key < this.keys[mid]) {<br />      return this.rank(key, lo, mid - 1)<br />    } else if (key > this.keys[mid]) {<br />      return this.rank(key, mid + 1, hi)<br />    } else {<br />      return mid<br />    }<br />  }<br />}<br />"}
{"index":{"_index":"codesearch"}}
{"name": "red-black-tree(binary-search tree)", "description": "红黑树(二叉查找树)","link":"https://github.com/originalix/algorithm/", "code": "const RED = true<br />const BLACK = false<br /><br />export class Node<K, V> {<br />  public key: K<br />  public val: V<br />  public left: Node<K, V><br />  public right: Node<K, V><br />  public N: number<br />  public color: boolean<br />  constructor(key: K, val: V, N: number, color: boolean) {<br />    this.key = key<br />    this.val = val<br />    this.N = N<br />    this.color = color<br />  }<br />}<br /><br />/**<br /> * 红黑树<br /> */<br />export default class RedBlackBST<K, V> {<br />  private root: Node<K, V><br />  constructor() {<br />    this.root = null<br />  }<br /><br />  size(): number {<br />    return this._size(this.root)<br />  }<br /><br />  private _size(h: Node<K, V>): number {<br />    if (h === null) return 0<br />    return h.N<br />  }<br /><br />  isEmpty() {<br />    return this.root === null<br />  }<br /><br />  isRed(h: Node<K, V>): boolean {<br />    if (h === null) return false<br />    return h.color === RED<br />  }<br /><br />  // 查找 key，找到则更新其值，否则为它新建一个结点<br />  put(key: K, val: V) {<br />    this.root = this._put(this.root, key, val)<br />    this.root.color = BLACK<br />  }<br /><br />  private _put(h: Node<K, V>, key: K, val: V) {<br />    // 标准的插入操作，和父结点用红链接相连<br />    if (h === null) return new Node<K, V>(key, val, 1, RED)<br /><br />    if (key < h.key) h.left = this._put(h.left, key, val)<br />    else if (key > h.key) h.right = this._put(h.right, key, val)<br />    else h.val = val<br /><br />    if (this.isRed(h.right) && !this.isRed(h.left)) h = this.rotateLeft(h)<br />    if (this.isRed(h.left) && this.isRed(h.left.left)) h = this.rotateRight(h)<br />    if (this.isRed(h.left) && this.isRed(h.right)) this.flipColors(h)<br /><br />    h.N = this._size(h.left) + this._size(h.right) + 1<br />    return h<br />  }<br /><br />  // 返回给定 key 关联的 value，如果不存在则返回 null<br />  get(key: K): V {<br />    return this._get(this.root, key)<br />  }<br /><br />  private _get(h: Node<K, V>, key: K): V {<br />    while (h !== null) {<br />      if (key < h.key) h = h.left<br />      else if (key > h.key) h = h.right<br />      else return h.val<br />    }<br />    return null<br />  }<br /><br />  // 检测 key 是否存在<br />  contains(key: K) {<br />    return this.get(key) !== null<br />  }<br /><br />  rotateLeft(h: Node<K, V>): Node<K, V> {<br />    const x = h.right<br />    h.right = x.left<br />    x.left = h<br />    x.color = h.color<br />    h.color = RED<br />    x.N = h.N<br />    h.N = 1 + this._size(h.left) + this._size(h.right)<br />    return x<br />  }<br /><br />  rotateRight(h: Node<K, V>): Node<K, V> {<br />    const x = h.left<br />    h.left = x.right<br />    x.right = h<br />    x.color = h.color<br />    h.color = RED<br />    x.N = h.N<br />    h.N = 1 + this._size(h.left) + this._size(h.right)<br />    return x<br />  }<br /><br />  flipColors(h: Node<K, V>) {<br />    h.color = RED<br />    h.left.color = BLACK<br />    h.right.color = BLACK<br />  }<br />}<br />"}
{"index":{"_index":"codesearch"}}
{"name": "sequential-search", "description": "顺序查找(基于无序链表)","link":"https://github.com/originalix/algorithm/", "code": "// 链表结点的定义<br />export class Node<Key, Value> {<br />  public key: Key<br />  public val: Value<br />  public next: Node<Key, Value><br />  constructor(key: Key, val: Value, next: Node<Key, Value>) {<br />    this.key = key<br />    this.val = val<br />    this.next = next<br />  }<br />}<br /><br />/**<br /> * 顺序查找（基于无序链表）<br /> */<br />export default class SequentialSearchST<Key, Value> {<br />  private first: Node<Key, Value> // 链表首结点<br />  private N: number<br /><br />  constructor() {<br />    this.first = null<br />    this.N = 0<br />  }<br /><br />  size(): number {<br />    return this.N<br />  }<br /><br />  keys(): Key[] {<br />    const keys = []<br />    while (this.first !== null) {<br />      keys.push(this.first.key)<br />      this.first = this.first.next<br />    }<br />    return keys<br />  }<br /><br />  // 查找给定的键，返回相关联的值<br />  get(key: Key): Value {<br />    for (let x = this.first; x !== null; x = x.next) {<br />      if (key === x.key) return x.val<br />    }<br />    return null<br />  }<br /><br />  // 查找给定的键，找到则更新其值，否则在表中新建节点<br />  put(key: Key, val: Value) {<br />    for (let x = this.first; x !== null; x = x.next) {<br />      if (key === x.key) {<br />        x.val = val<br />        return<br />      }<br />    }<br />    this.first = new Node<Key, Value>(key, val, this.first)<br />    this.N++<br />  }<br /><br />  delete(key: Key) {<br />    if (key === null) throw new Error('argument to delete() is null')<br />    return this._delete(this.first, key)<br />  }<br /><br />  private _delete(node: Node<Key, Value>, key: Key) {<br />    if (node === null) return null<br />    if (key === node.key) {<br />      this.N--<br />      return node.next<br />    }<br />    node.next = this._delete(node.next, key)<br />    return node<br />  }<br />}<br />"}
{"index":{"_index":"codesearch"}}
{"name": "base-sort", "description": "基础排序","link":"https://github.com/originalix/algorithm/", "code": "/**<br /> * 排序 基础接口<br /> */<br />export interface ISort<T = number> {<br />  sort: (array?: T[]) => void<br />  less: (v: T, w: T) => boolean<br />  show: () => void<br />  isSorted: () => boolean<br />  main: (passArray?: boolean) => void<br />}<br /><br />import { ISort } from '@/types'<br />import assert = require('assert')<br /><br />abstract class BaseSort<T> implements ISort<T> {<br />  protected array: T[]<br /><br />  constructor(array: T[]) {<br />    this.array = array<br />  }<br /><br />  abstract sort(array?: T[]): void<br /><br />  less(v: T, w: T): boolean {<br />    return v < w<br />  }<br /><br />  exch(i: number, j: number) {<br />    const temp = this.array[i]<br />    this.array[i] = this.array[j]<br />    this.array[j] = temp<br />  }<br /><br />  show(): void {<br />    console.log(this.array)<br />  }<br /><br />  isSorted(): boolean {<br />    for (let i = 1; i < this.array.length; i++) {<br />      if (this.less(this.array[i], this.array[i - 1])) return false<br />    }<br />    return true<br />  }<br /><br />  main(passArray?: boolean) {<br />    passArray ? this.sort(this.array) : this.sort()<br />    assert(this.isSorted(), '数组排序错误')<br />    this.show()<br />  }<br />}<br /><br />export default BaseSort<br />"}
{"index":{"_index":"codesearch"}}
{"name": "heap-sort", "description": "堆排序","link":"https://github.com/originalix/algorithm/", "code": "/**<br /> * 堆排序<br /> */<br />export default class HeapSort<T> {<br />  sort(arr: T[]) {<br />    let N = arr.length<br />    for (let k = Math.floor(N / 2); k >= 1; k--) {<br />      this.sink(arr, k, N)<br />    }<br />    while (N > 1) {<br />      this.exch(arr, 1, N--)<br />      this.sink(arr, 1, N)<br />    }<br />  }<br /><br />  private sink(arr: T[], dad: number, N: number) {<br />    while (2 * dad <= N) {<br />      let son = 2 * dad<br />      if (son < N && this.less(arr, son, son + 1)) son++<br />      if (!this.less(arr, dad, son)) break<br />      this.exch(arr, dad, son)<br />      dad = son<br />    }<br />  }<br /><br />  private exch(arr: T[], i: number, j: number) {<br />    const temp = arr[i - 1]<br />    arr[i - 1] = arr[j - 1]<br />    arr[j - 1] = temp<br />  }<br /><br />  private less(arr: T[], i: number, j: number) {<br />    return arr[i - 1] < arr[j - 1]<br />  }<br /><br />  isSorted(arr: T[]): boolean {<br />    for (let i = 1; i < arr.length; i++) {<br />      if (this.less(arr, i, i - 1)) return false<br />    }<br />    return true<br />  }<br />}<br />"}
{"index":{"_index":"codesearch"}}
{"name": "insertion", "description": "插入排序","link":"https://github.com/originalix/algorithm/", "code": "import BaseSort from './base-sort'<br /><br />/**<br /> * 插入排序<br /> */<br />export default class Insertion<T> extends BaseSort<T> {<br />  sort() {<br />    const N = this.array.length<br />    for (let i = 1; i < N; i++) {<br />      for (let j = i; j > 0 && this.less(this.array[j], this.array[j - 1]); j--) {<br />        this.exch(j, j - 1)<br />      }<br />    }<br />  }<br />}<br />"}
{"index":{"_index":"codesearch"}}
{"name": "merge-sort", "description": "归并排序","link":"https://github.com/originalix/algorithm/", "code": "import BaseSort from './base-sort'<br /><br />/**<br /> * 归并排序<br /> */<br />export default class MergeSort<T> extends BaseSort<T> {<br />  private aux: T[] // 归并所需的辅助数组<br /><br />  sort(arr: T[]) {<br />    this.aux = []<br />    this._sort(arr, 0, arr.length - 1)<br />  }<br /><br />  private _sort(arr: T[], lo: number, hi: number) {<br />    if (hi <= lo) return<br />    const mid = lo + Math.floor((hi - lo) / 2)<br />    this._sort(arr, lo, mid) // 将左半边排序<br />    this._sort(arr, mid + 1, hi) // 将右半边排序<br />    this.merge(arr, lo, mid, hi) // 归并结果<br />  }<br /><br />  private merge(arr: T[], lo: number, mid: number, hi: number) {<br />    // 将 arr[lo..mid] 和 arr[mid+1..hi] 归并jj<br />    let i = lo<br />    let j = mid + 1<br />    for (let k = lo; k <= hi; k++) {<br />      // 将 arr[lo..hi] 复制到aux[lo..hi]<br />      this.aux[k] = arr[k]<br />    }<br />    for (let k = lo; k <= hi; k++) {<br />      // 归并回到arr[lo..hi]<br />      if (i > mid) arr[k] = this.aux[j++]<br />      else if (j > hi) arr[k] = this.aux[i++]<br />      else if (this.less(this.aux[j], this.aux[i])) arr[k] = this.aux[j++]<br />      else arr[k] = this.aux[i++]<br />    }<br />  }<br />}<br />"}
{"index":{"_index":"codesearch"}}
{"name": "quick-sort", "description": "快速排序","link":"https://github.com/originalix/algorithm/", "code": "import BaseSort from './base-sort'<br /><br />export default class QuickSort<T> extends BaseSort<T> {<br />  sort(arr: T[]) {<br />    this._sort(arr, 0, arr.length - 1)<br />  }<br /><br />  private _sort(arr: T[], lo: number, hi: number) {<br />    if (hi <= lo) return<br />    const j = this.partition(arr, lo, hi) // 切分<br />    this._sort(arr, lo, j - 1) // 将左半边部分arr[lo..j-1]排序<br />    this._sort(arr, j + 1, hi) // 将右半边部分arr[j+1..hi]排序<br />  }<br /><br />  private partition(arr: T[], lo: number, hi: number): number {<br />    let i = lo<br />    let j = hi + 1 // 左右扫描指针<br />    const v = arr[lo] // 切分元素<br />    while (true) {<br />      // 扫描左右，检查扫描是否结束并交换元素<br />      while (this.less(arr[++i], v)) if (i === hi) break<br />      while (this.less(v, arr[--j])) if (j === lo) break<br />      if (i >= j) break<br />      this.exch(i, j)<br />    }<br />    this.exch(lo, j) // 将 v=a[j] 放入正确的位置<br />    return j // arr[lo..j-1] <= arr[j] <= arr[j+1..hi] 达成<br />  }<br />}<br />"}
{"index":{"_index":"codesearch"}}
{"name": "selection", "description": "选择排序","link":"https://github.com/originalix/algorithm/", "code": "import BaseSort from './base-sort'<br /><br />/**<br /> * 选择排序<br /> */<br />export default class Selection<T> extends BaseSort<T> {<br />  sort() {<br />    const N = this.array.length<br />    for (let i = 0; i < N; i++) {<br />      let min = i<br />      for (let j = i + 1; j < N; j++) {<br />        if (this.less(this.array[j], this.array[min])) min = j<br />      }<br />      this.exch(i, min)<br />    }<br />  }<br />}<br />"}
{"index":{"_index":"codesearch"}}
{"name": "shell-sort", "description": "希尔排序","link":"https://github.com/originalix/algorithm/", "code": "import BaseSort from './base-sort'<br /><br />/**<br /> * 希尔排序<br /> */<br />export default class ShellSort<T> extends BaseSort<T> {<br />  sort() {<br />    const N = this.array.length<br />    let h = 1<br />    while (h < N / 3) h = h * 3 + 1<br />    while (h >= 1) {<br />      for (let i = h; i < N; i++) {<br />        for (let j = i; j >= h && this.less(this.array[j], this.array[j - h]); j -= h) {<br />          this.exch(j, j - h)<br />        }<br />      }<br />      h = Math.floor(h / 3)<br />    }<br />  }<br />}<br />"}
