{"index":{"_index":"codesearch"}}
{"name": "queue","description": "先进先出队列的链表实现","code": "node-queue.ts"}
{"index":{"_index":"codesearch"}}
{"name": "stack","description": "下压栈的链表实现","code": "node-stack.ts"}
{"index":{"_index":"codesearch"}}
{"name": "resizing-stack","description": "能够动态调整大小的下压栈","code": "resizing-array-stack.ts"}
{"index":{"_index":"codesearch"}}
{"name": "simple-calculate","description": "Dijkstra双栈进行算术表达式的求值计算","code": "export default class Evaluate {<br />  static main(args: string) {<br />    const ops: string[] = []<br />    const vals: number[] = []<br /><br />    for (let i = 0; i < args.length; i++) {<br />      const char = args.charAt(i)<br />      if (char.match(/\\s/)) continue<br />      if (char === '(') continue<br />      if (['+', '-', '*', '/'].includes(char)) {<br />        ops.push(char)<br />      } else if (char === ')') {<br />        const op = ops.pop()<br />        let v = vals.pop()<br />        if (op === '+') v = vals.pop() + v<br />        if (op === '-') v = vals.pop() - v<br />        if (op === '*') v = vals.pop() * v<br />        if (op === '/') v = vals.pop() / v<br />        vals.push(v)<br />      } else {<br />        vals.push(parseFloat(char))<br />      }<br />    }<br /><br />    return vals.pop()<br />  }<br />}<br />"}
{"index":{"_index":"codesearch"}}
{"name": "binary-search tree", "description": "二叉查找树", "code": "interface IBst<K, V> extends ICommonFn {<br />  get: (key: K) => V | null<br />  put: (key: K, val: V) => void<br />  rank: (key: K) => number<br />  min: () => K<br />  max: () => K<br />  floor: (key: K) => K<br />  select: (key: number) => K<br />  deleteMin: () => void<br />  delete: (key: K) => void<br />  keys: (lo: K, hi: K) => K[]<br />}<br /><br />export class Node<K, V> {<br />  public key: K<br />  public val: V<br />  public left: Node<K, V> // 指向树的链接<br />  public right: Node<K, V><br />  public N: number // 以该节点为根的子树中的结点总数<br />  constructor(key: K, val: V, N: number) {<br />    this.key = key<br />    this.val = val<br />    this.N = N<br />    this.left = null<br />    this.right = null<br />  }<br />}<br /><br />/**<br /> * 二叉查找树<br /> */<br />export default class BST<K, V> implements IBst<K, V> {<br />  private root: Node<K, V> // 二叉查找树根节点<br />  constructor() {<br />    this.root = null<br />  }<br /><br />  size(): number {<br />    return this._size(this.root)<br />  }<br /><br />  private _size(x: Node<K, V>): number {<br />    if (x === null) return 0<br />    else return x.N<br />  }<br /><br />  isEmpty() {<br />    return this.size() === 0<br />  }<br /><br />  get(key: K) {<br />    return this._get(this.root, key)<br />  }<br /><br />  // 在以 x 为根节点的子树中查找并返回 key 对应的值<br />  private _get(x: Node<K, V>, key: K): V | null {<br />    // 如果找不到则返回 null<br />    if (x === null) return null<br />    if (key < x.key) {<br />      return this._get(x.left, key)<br />    } else if (key > x.key) {<br />      return this._get(x.right, key)<br />    } else {<br />      return x.val<br />    }<br />  }<br /><br />  // 查找 key， 找到则更新它的值，否则为它创建一个新的节点<br />  put(key: K, val: V) {<br />    this.root = this._put(this.root, key, val)<br />  }<br /><br />  // 如果 key 存在于以 x 为根节点的子树中则更新它的值<br />  // 否则将以 key 和 val 为键值对的新节点插入到该子树中<br />  private _put(x: Node<K, V>, key: K, val: V): Node<K, V> {<br />    if (x === null) return new Node(key, val, 1)<br />    if (key < x.key) {<br />      x.left = this._put(x.left, key, val)<br />    } else if (key > x.key) {<br />      x.right = this._put(x.right, key, val)<br />    } else {<br />      x.val = val<br />    }<br />    x.N = this._size(x.left) + this._size(x.right) + 1<br /><br />    return x<br />  }<br /><br />  // 查找最小键<br />  min(): K {<br />    return this._min(this.root)?.key<br />  }<br /><br />  private _min(x: Node<K, V>): Node<K, V> {<br />    if (x.left === null) return x<br />    return this._min(x.left)<br />  }<br /><br />  max(): K {<br />    return this._max(this.root)?.key<br />  }<br /><br />  private _max(x: Node<K, V>): Node<K, V> {<br />    if (x.right === null) return x<br />    return this._max(x.right)<br />  }<br /><br />  // 向上取整<br />  floor(key: K) {<br />    const x = this._floor(this.root, key)<br />    if (x === null) return null<br />    return x.key<br />  }<br /><br />  private _floor(x: Node<K, V>, key: K): Node<K, V> {<br />    if (x === null) return null<br />    if (key === x.key) return x<br />    if (key < x.key) return this._floor(x.left, key)<br />    const t = this._floor(x.right, key)<br />    return t !== null ? t : x<br />  }<br /><br />  //  选择操作<br />  select(k: number) {<br />    return this._select(this.root, k)?.key<br />  }<br /><br />  // 返回排名为 k 的节点<br />  private _select(x: Node<K, V>, k: number): Node<K, V> {<br />    if (x === null) return null<br />    const t = this._size(x.left)<br />    if (t > k) return this._select(x.left, k)<br />    else if (t < k) return this._select(x.right, k - t - 1)<br />    else return x<br />  }<br /><br />  // 排名<br />  rank(key: K): number {<br />    return this._rank(key, this.root)<br />  }<br /><br />  // 返回以 x 为根节点的子树中小于 x.key 的数量<br />  private _rank(key: K, x: Node<K, V>): number {<br />    if (x === null) return 0<br />    if (key < x.key) {<br />      return this._rank(key, x.left)<br />    } else if (key > x.key) {<br />      return 1 + this._size(x.left) + this._rank(key, x.right)<br />    } else {<br />      return this._size(x.left)<br />    }<br />  }<br /><br />  // 删除最小键<br />  deleteMin() {<br />    this.root = this._deleteMin(this.root)<br />  }<br /><br />  private _deleteMin(x: Node<K, V>): Node<K, V> {<br />    if (x.left === null) return x.right<br />    x.left = this._deleteMin(x.left)<br />    x.N = this._size(x.left) + this._size(x.right) + 1<br />    return x<br />  }<br /><br />  // 删除操作<br />  delete(key: K) {<br />    this.root = this._delete(this.root, key)<br />  }<br /><br />  /**<br />   * 删除算法步骤<br />   * 1、将指向即将被删除的节点的链接保存为 t<br />   * 2、将 x 指向它的后继节点 min(t.right)<br />   * 3、将 x 的右链接(原本指向一颗所有节点都大于x.key的二叉查找树)指向 deleteMin(t.right)，也就是在删除后所有结点仍然都大于 x.key 的子二叉查找树<br />   * 4、将 x 的左连接(本为空)设为t.left(其下所有的键都小于被删除的结点和它的后继结点)<br />   */<br />  private _delete(x: Node<K, V>, key: K): Node<K, V> {<br />    if (x === null) return null<br />    if (key < x.key) {<br />      x.left = this._delete(x.left, key)<br />    } else if (key > x.key) {<br />      x.right = this._delete(x.right, key)<br />    } else {<br />      if (x.right === null) return x.left<br />      if (x.left === null) return x.right<br />      const t = x<br />      x = this._min(t.right)<br />      x.right = this._deleteMin(t.right)<br />      x.left = t.left<br />    }<br />    x.N = this._size(x.left) + this._size(x.right) + 1<br />    return x<br />  }<br /><br />  // 范围查找<br />  keys(lo: K, hi: K) {<br />    const queue: K[] = []<br />    this._keys(this.root, queue, lo, hi)<br />    return queue<br />  }<br /><br />  // 中序遍历<br />  private _keys(x: Node<K, V>, queue: K[], lo: K, hi: K) {<br />    if (x === null) return<br />    if (lo < x.key) this._keys(x.left, queue, lo, hi)<br />    if (lo <= x.key && hi >= x.key) queue.push(x.key)<br />    if (hi > x.key) this._keys(x.right, queue, lo, hi)<br />  }<br />}<br />"}
{"index":{"_index":"codesearch"}}
{"name": "binary-search(array)", "description": "二分查找的有序数组实现", "code": "interface IBst<K, V> extends ICommonFn {<br />  get: (key: K) => V | null<br />  put: (key: K, val: V) => void<br />  rank: (key: K) => number<br />  min: () => K<br />  max: () => K<br />  floor: (key: K) => K<br />  select: (key: number) => K<br />  deleteMin: () => void<br />  delete: (key: K) => void<br />  keys: (lo: K, hi: K) => K[]<br />}<br /><br />export default class BinarySearchST<Key, Value> implements ISearch<Key, Value> {<br />  private keys: Key[]<br />  private vals: Value[]<br />  private N: number<br /><br />  constructor() {<br />    this.keys = []<br />    this.vals = []<br />    this.N = 0<br />  }<br /><br />  size(): number {<br />    return this.N<br />  }<br /><br />  isEmpty(): boolean {<br />    return this.N === 0<br />  }<br /><br />  contains(key: Key) {<br />    return this.get(key) != null<br />  }<br /><br />  getKeys() {<br />    return this.keys<br />  }<br /><br />  get(key: Key): Value | null {<br />    if (this.isEmpty()) return null<br />    const i = this.rank(key, 0, this.N - 1)<br />    if (i < this.N && this.keys[i] === key) {<br />      return this.vals[i]<br />    } else {<br />      return null<br />    }<br />  }<br /><br />  // 查找键，找到则更新值，否则创建新的元素:w<br />  put(key: Key, val: Value) {<br />    const i = this.rank(key, 0, this.N - 1)<br />    if (i < this.N && this.keys[i] === key) {<br />      this.vals[i] = val<br />      return<br />    }<br />    for (let j = this.N; j > i; j--) {<br />      this.keys[j] = this.keys[j - 1]<br />      this.vals[j] = this.vals[j - 1]<br />    }<br />    this.keys[i] = key<br />    this.vals[i] = val<br />    this.N++<br />  }<br /><br />  rank(key: Key, lo: number, hi: number): number {<br />    if (hi < lo) return lo<br />    const mid = Math.floor(lo + (hi - lo) / 2)<br />    if (key < this.keys[mid]) {<br />      return this.rank(key, lo, mid - 1)<br />    } else if (key > this.keys[mid]) {<br />      return this.rank(key, mid + 1, hi)<br />    } else {<br />      return mid<br />    }<br />  }<br />}<br />"}
{"index":{"_index":"codesearch"}}
{"name": "red-black-tree(binary-search tree)", "description": "红黑树(二叉查找树)", "code": "const RED = true<br />const BLACK = false<br /><br />export class Node<K, V> {<br />  public key: K<br />  public val: V<br />  public left: Node<K, V><br />  public right: Node<K, V><br />  public N: number<br />  public color: boolean<br />  constructor(key: K, val: V, N: number, color: boolean) {<br />    this.key = key<br />    this.val = val<br />    this.N = N<br />    this.color = color<br />  }<br />}<br /><br />/**<br /> * 红黑树<br /> */<br />export default class RedBlackBST<K, V> {<br />  private root: Node<K, V><br />  constructor() {<br />    this.root = null<br />  }<br /><br />  size(): number {<br />    return this._size(this.root)<br />  }<br /><br />  private _size(h: Node<K, V>): number {<br />    if (h === null) return 0<br />    return h.N<br />  }<br /><br />  isEmpty() {<br />    return this.root === null<br />  }<br /><br />  isRed(h: Node<K, V>): boolean {<br />    if (h === null) return false<br />    return h.color === RED<br />  }<br /><br />  // 查找 key，找到则更新其值，否则为它新建一个结点<br />  put(key: K, val: V) {<br />    this.root = this._put(this.root, key, val)<br />    this.root.color = BLACK<br />  }<br /><br />  private _put(h: Node<K, V>, key: K, val: V) {<br />    // 标准的插入操作，和父结点用红链接相连<br />    if (h === null) return new Node<K, V>(key, val, 1, RED)<br /><br />    if (key < h.key) h.left = this._put(h.left, key, val)<br />    else if (key > h.key) h.right = this._put(h.right, key, val)<br />    else h.val = val<br /><br />    if (this.isRed(h.right) && !this.isRed(h.left)) h = this.rotateLeft(h)<br />    if (this.isRed(h.left) && this.isRed(h.left.left)) h = this.rotateRight(h)<br />    if (this.isRed(h.left) && this.isRed(h.right)) this.flipColors(h)<br /><br />    h.N = this._size(h.left) + this._size(h.right) + 1<br />    return h<br />  }<br /><br />  // 返回给定 key 关联的 value，如果不存在则返回 null<br />  get(key: K): V {<br />    return this._get(this.root, key)<br />  }<br /><br />  private _get(h: Node<K, V>, key: K): V {<br />    while (h !== null) {<br />      if (key < h.key) h = h.left<br />      else if (key > h.key) h = h.right<br />      else return h.val<br />    }<br />    return null<br />  }<br /><br />  // 检测 key 是否存在<br />  contains(key: K) {<br />    return this.get(key) !== null<br />  }<br /><br />  rotateLeft(h: Node<K, V>): Node<K, V> {<br />    const x = h.right<br />    h.right = x.left<br />    x.left = h<br />    x.color = h.color<br />    h.color = RED<br />    x.N = h.N<br />    h.N = 1 + this._size(h.left) + this._size(h.right)<br />    return x<br />  }<br /><br />  rotateRight(h: Node<K, V>): Node<K, V> {<br />    const x = h.left<br />    h.left = x.right<br />    x.right = h<br />    x.color = h.color<br />    h.color = RED<br />    x.N = h.N<br />    h.N = 1 + this._size(h.left) + this._size(h.right)<br />    return x<br />  }<br /><br />  flipColors(h: Node<K, V>) {<br />    h.color = RED<br />    h.left.color = BLACK<br />    h.right.color = BLACK<br />  }<br />}<br />"}
{"index":{"_index":"codesearch"}}
{"name": "sequential-search", "description": "顺序查找(基于无序链表)", "code": "// 链表结点的定义<br />export class Node<Key, Value> {<br />  public key: Key<br />  public val: Value<br />  public next: Node<Key, Value><br />  constructor(key: Key, val: Value, next: Node<Key, Value>) {<br />    this.key = key<br />    this.val = val<br />    this.next = next<br />  }<br />}<br /><br />/**<br /> * 顺序查找（基于无序链表）<br /> */<br />export default class SequentialSearchST<Key, Value> {<br />  private first: Node<Key, Value> // 链表首结点<br />  private N: number<br /><br />  constructor() {<br />    this.first = null<br />    this.N = 0<br />  }<br /><br />  size(): number {<br />    return this.N<br />  }<br /><br />  keys(): Key[] {<br />    const keys = []<br />    while (this.first !== null) {<br />      keys.push(this.first.key)<br />      this.first = this.first.next<br />    }<br />    return keys<br />  }<br /><br />  // 查找给定的键，返回相关联的值<br />  get(key: Key): Value {<br />    for (let x = this.first; x !== null; x = x.next) {<br />      if (key === x.key) return x.val<br />    }<br />    return null<br />  }<br /><br />  // 查找给定的键，找到则更新其值，否则在表中新建节点<br />  put(key: Key, val: Value) {<br />    for (let x = this.first; x !== null; x = x.next) {<br />      if (key === x.key) {<br />        x.val = val<br />        return<br />      }<br />    }<br />    this.first = new Node<Key, Value>(key, val, this.first)<br />    this.N++<br />  }<br /><br />  delete(key: Key) {<br />    if (key === null) throw new Error('argument to delete() is null')<br />    return this._delete(this.first, key)<br />  }<br /><br />  private _delete(node: Node<Key, Value>, key: Key) {<br />    if (node === null) return null<br />    if (key === node.key) {<br />      this.N--<br />      return node.next<br />    }<br />    node.next = this._delete(node.next, key)<br />    return node<br />  }<br />}<br />"}
